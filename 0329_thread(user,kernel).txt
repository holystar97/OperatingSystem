### 스레드(Thread)
일반적으로 하나의 프로세스는 하나의 스레드를 가지고 프로그램을 실행시킨다.
이러한 환경에서는 다른 작업을 처리해야 하는 경우 프로세서를 추가 생성해야 하며,
같은 응용프로그램 내부에서 context-switch가 필요할 때 프로세스 간 context-switch가 발생하게 된다.
프로세스는 생성, context-switch 등 작업 수행 시 많은 비용이 소요가 된다는 단점이 있다.
예를 들어 linux의 대표적인 프로세스 생성 시스템 콜 fork() 함수를 사용하더라도 fork()시 작업이 일시정지되고
부모 프로세스의 정보(레지스터, 힙 등)를 자식 프로세스에게 주입해야한다. 이와 같이 프로세스의 단점을
상쇄하고자 스레드가 고안되었다. 프로세스는 내부에 작업 단위 별 스레드를 생성하여 작업 처리 효율을 높일 수 가 있다.

### 사용자 레벨(User-level Thread), 커널 레벨(Kernel-level Thread)
 스레드는 스케쥴링 주체에 따라 사용자, 커널로 나누어진다.
 사용자 레벨 스레드는 사용자 라이브러리에 의해 스케쥴링 되며
 커널 레벨 스레드는 커널 스케쥴러에 의해 스케쥴링 되는 스레드이다.

### 커널 레벨 스레드
 커널 레벨 스레드는 스레드에 관한 정보 테이블은 TCB를 커널이 가지고 있으며 커널에 의해 스케쥴링 된다.

### 사용자 레벨 스레드
 운영체제 내 스레드 관련 라이브러리로 생성된 스레드들이다. 사용자 레벨 스레드는 커널이 아닌 라이브러리 내 스케쥴러에 의해 관리된다. 커널은 사용자 레벨 스레드의 현황을 알지 못한다. 사용자 레벨 스레드 관련 라이브러리로는 자바 스레드, POSIX Pthread, WIN 32 등이 있다.

※ 사용자 스레드 라이브러리
 개발자가 스레드를 생성하고 관리할 수 있는 기능을 제공하는 API이다. 모든 기능이 사용자 영역에서 사용되어지고 구현되므로 커널 영역 호출을 하지 않아도 사용자 영역에서 작업 처리가 가능하다.(물론 예외적으로 I/O 처리는 커널영역에서 해야된다.) 이 때문에 커널 스레드에 비해 처리 속도가 빠르며 처리에 대한 오버헤드가 감소하는 장점이 있다.

### 사용자 레벨 스레드의 특성
 커널에 의해 관리 되지 않고 사용자 라이브러리를 이용하여 생성되고 관리되는 특성이 있다.
이 때문에 개발자가 개발하기 수월하며, context-swtich 시 커널 영역까지 내려가서 처리하지 않아도 되므로
context-swtich가 빠른 장점이 있다. 하지만, 실질적으로 처리를 주도하는 커널 관점에서는 사용자 스레드의 현황을 알지 못하기 때문에 병렬적 처리에 한계가 있으며, 하나의 사용자 스레드가 시스템 호출 등으로 block 상태가 되면
다른 스레드들도 일시정지가 되기 때문에 다른 스레드들에도 영향을 끼친다.

### 다중 스레드 모델
§ 1 : N
 하나의 커널 스레드와 다수의 사용자 스레드로 운영하는 방식이다. 커널 스레드를 프로세스 당 1개만 생성하므로 커널 스레드 생성 비용이 감소하고 응용프로그램 내부에 사용자 스레드를 생성할 수 있어 동시에 수행하는 작업량이 증가한다. 하지만, 사용자 스레드 갯수와 상관없이 커널 스레드는 하나이므로 병렬적 처리에 한계가 있으며 하나의 사용자 스레드가 시스템 호출을 할 경우 해당 프로세스가 일시 정지되는 단점이 있다. 단일 코어 프로세를 주로 사용했던 시기에 채택된 방식이다. 주로 Solaris, Java 초기 버전에서 사용되었으나 멀티 프로세서의 발전으로 사용되어 지는 방식은 아니다.

§ 1 : 1
 하나의 커널 스레드가 하나의 사용자 스레드와 매칭되어 운영되는 방식이다. 하나의 커널 스레드가 하나의 사용자 스레드를 처리하는 방식이기에 병렬적 처리가 우수하며, 1:N 모델과 다르게 하나의 사용자 스레드가 시스템 호출을 하더라도 다른 스레드들의 작업 처리를 보장받을 수 있다. 단점으로는 커널 스레드의 생성 비용이 증가하며 병렬적 처리를 위한 CPU 제원사항이 높아진다. 현대 운영체제에는 멀티 코어 프로세서의 발전으로 1:1 방식이 주로 사용되어 진다. 현재 linux, window 등에 사용하고 있는 기법이다.

§ M : N
 1:1 방식과 1:N 방식을 혼합하여 운영하는 방식이다. 1:1 방식보다 커널 스레드 개체가 적어 생성비용에 이득이나, 구현방법이 복잡하여 Solaris 9 이전까지는 사용한 방식이었으나 9 버전 이후로는 사용하지 않는 방식이다.
