


응용프로그램이 자원을 접근하는것은 문제이다. 
현대의 운영체제의 대부분은 다중프로그래밍 운영체제이다. 

SS 다중/멀티 프로그래밍 vs 멀티 태스킹

배치 프로그램 - 다중 프로그램 
다중 프로그램- io등 idle 시간에 cpu가 다른 프로그램에게 주는것을 말한다. 
시분할 운영체제 - timeslice를 주어서 멀티 태스킹을 만들어내는 기법 
멀티 태스크 - 여러개의 task를 운영체제가 실행시킨다.

1. 다수의 응용 프로그램이 동시에 실행한다. 
cpu가 한개 있으면 프로그램이 2개가 메모리에 올라와있다고 하더라도
한번에 하나씩 실행한다. io가 발생하든 timeslice가 발생하면 잠깐 쉬고있지만
일을 하는것을 동시에 라고 한다. 
두 프로세스를 서비스를 받고잇다고 보기때문이다. 

SS  멀티 스레딩  

concurrent processing 동시실행 프로세스
한사람이 여러 업무를 할 때는 concurrency 라고한다.
주방장이 하나이고 여러사람이 들어왔다. 따라서 혼자 라면 물, 스프 등등 
넣고 하는것을 concurreny 

병렬성은 parallel 실행 프로세스라고한다. 
주방장이 5명이여서 동시에 돌리는것이다. 


위 두가지 동시성과 병렬성을 모두 포함하고 있는 개념이라고 보면 된다.

SS 응용 프로그램이 직접 컴퓨터 자원에 접근하면 충돌과 훼손 발생가능
메모리 훼손 가능
파일 삭제
커널 영역 훼손 가능 

3. 따라서 해결책 

자원에 대한 모든 기능 커널에 부여
메모리를 사용자 공간과 커널 공간으로 분리

커널 공간안에 있는 코드가 다른 응용 프로그램의 방해를 받지 않고
독립적으로 보호된 상황에서 실행할 수 있도록 해야한다. 

** 사용자 공간과 커널 공간 

메모리 칩을 사면 사용자 공간의 메모리와 커널 공간의 메모리를 따로 두는것은 아니다. 이를 나누는것은 운영체제가 하는것이다. 
32bit cpu를 가진 운영체제 라고 한다면 
4GB의 주소공간을 최대 사용할 수 있다.
그중 2GB는 사용자 공간으로 사용하고 2GB는 커널 공간으로 쓴다고 나누었다

SS여기서 이와 같은 분리는 어떤 의미를 가지는가 ? 

실제 메모리는 4GB라고 하더라도 실제 메모리를 사용하는것은 사실 4GB보다 작다. 따라서 이 메모리 공간은 실제 메모리를 가리키는 것이 가상 공간을 말합니다. 여기서 공간이라는 말은 주소 범위라고 해석하면 됩니다.


사용자 응용 프로그램이 접근할 수 있는 주소 범위는 최대 2GB 까지 허용한다는 의미라고 볼 수 있습니다. 프로그램을 작성하면 논리공간/ 가상 공간 즉 
0번지로 볼 수 있습니다 그리고 7FFFFFF 번지까지만 응용 프로그램이 접근할 수 잇는 범위가 되는것입니다. 따라서 8FFFFF번지를 접근하려고 하는 순간 
커널 공간에 있는 주소 공간에 접근한 것이 되는것이므로 악의적이거나 실수라고 판단하고 프로그램을 종료시킨다. 리눅스의 경우 3GB까지 컴파일을 허용을한다. 하지만 1GB는 커널 공간에 할당한다. 

2GB의 번지는 상대주소/ 논리주소라고 한다. 운영체제는 논리주소 0번지에서 7FFFFF번지까지만 응용 프로그램이 접근할 수 있는 공간 범위이고 
그 외는 커널 만이 접근할 수 잇는 공간 범위이다.

이와 같이 메모리 공간을 분리한 이유는 독립성과 보안을 지키기위해서이다.
실수로 커널에 접근하여 데이터를 써서 커널이 망가지는것을 막기위해서이다.

예를 들어서 
SS세개의 프로세스가 돌고있다면 메모리는 어떻게 되는것입니까 ? 

사용자 공간은 운영체제가 볼 때는 사용자 공간 범위내에서만 가능하도록 허용하는것이고 프로세스 입장에서 봤을떄는 2GB까지만 프로그램을 작성할 수 있다는 뜻이다.

SS 실제 주소인지 물리주소인지 알수있나요 ?
물리주소는 아무도 몰라요 운영체제도 잘 모르고 실행을 해봐야아는것이다.
논리주소는 우리가 아는것이다, 몇번지 인지 아는것이다. 
INT P;
INT *P= &N;
이럴 경우 P의 주소가 12345678 이 나왔다면
변수 N 의 주소는 12345678 이라고 나오는것은 논리주소이다. 
물리주소는 몇번지라고 할 수가 없다. 
주소버스에 담겨진 주소가 물리 주소이다. 

SS 논리주소랑 물리주소랑 바꾸는 매핑 테이블은 
커널 영역 내 있다. 커널이 관리하게 된다. 메모리 관리에서 배우게 된다. 
실제로는 페이지 테이블이라고 부른다.
프로그램을 로딩해서 프로세스를 만들게 되면 물리메모리를 만들게 되고 
매핑하게 되는 매핑 테이블을 만들게 되고 커널이 매핑 테이블을 관리한다. 

SS 

SS실제 메모리랑 비교하라 

SS가상 메모리 공간 0번지와 다른 프로세스의 0번지랑 충돌이 일어나느 경우는 ? 

SS실제메모리가 만약 1GB밖에 남아있지 않다면 어떻합니까 ?


--> 매핑 테이블이 있기 때문에 실제 메모리의 공간에 할당이 되는 구조이다.
프로세스 별로 매핑 테이블이 적혀있다. 따라서 논리주소는 같더라도 실제주소랑은 다르게 배치가 되기 때문에 충돌이 일어나지 않는다.
논리주소가 실제로는 물리주소로 바뀌어서 엑세스 되는것이다.  
물리메모리의 빈자리에 각 프로세스의 영역들이 분산되어서 저장이 되게 된다
마찬가지로 커널 영역역시 매핑 테이블을 거쳐서 메모리에 저장이 되게 된다.  

SS만약에 사용자 공간으로 주어진 전체 크기 만큼으로 큰 프로그램이 작성되어져 있다고 한다면 1GB 로 부족할때는 ? 


하드디스크로 이동시킨다. 따라서 메모리를 비우고 다시 프로세스의 남은 논리주소의 공간들이 일어난다. 즉 필요한 메모리만 물리메모리에 올려놓고 
돌린다. 만약 필요한 데이터가 잇는경우 다시 하드디스크에서 빈 메모리로 다시 올리고 다시 코드를 실행한다. 

SS 물리주소도 사용자 공간과 커널공간이 나누어져있나요 ?
네 나누어 져있다. 프로세스 A와 프로세스 B는 동일한 공간을 가리키고 있다.
즉 커널공간도 따로 있다. 프로세스는 4GB 가 중에서 2GB는 내가 쓰는것 
2GB는 운영체제 커널이 쓰는것이라고 보고, 운영체제 영역은 공유가 되고 있고 사용자 영역은 메모리를 분할해서 사용하고 있는것이다. 


SS 사용자 모드와 커널 모드 

SS 누구한테 이 모드가 설정이 되는가 ?
CPU 내부에 보면 모드 레지스터라는 곳에 저장이 된다.
0이 사용자 모드 1이 커널 모드 가 된다. 

SS 사용자 모드란 ? 
CPU는 사용자 공간에 잇는 코드를 실행하는 중이다. 국한된다. 
사용자 모드에서는 커널 공간에 는 접근 불가한다
하드웨어어 접근 불가 하다. 특권명령어를 사용할 수 없다.
사용자 모드에서 사용자 프로그램이 오류 발생하면 프로그램 종료  

SS 커널 모드란 ? 
커널 영역의 메모리 번지에 해당하는 메모리를 실행을 할 수 있다. 
사용자 영역의 어떤 번지를 엑세스 한다고 할지라도  이 역시도 OK 이다
어디든지 엑세스 할 수 있다. 모든 하드웨어 접근 가능하다. 특권명령을 포함한 CPU의 모든 기계 명령어도 가능하다. 
커널 모드에서 오류 발생하면 시스템이 종료된다. 

SS 사용자모드에서 커널 모드로 변경되는 경우는 ?

2가지 있다.
시스템 호출과 인터럽트가 발생한다

SS 커널 모드로 변경하는 것은 어떤 의미를 가지게 되는가 ? 

시스템 호출, 인터럽트 발생으로 커널 모드가 실행되면 
인터럽트 서비스 루틴이 커널 영역이 있으므로 
그 외에는 커널 코드를 전혀 실행 할 수 없다는 뜻이 된다.
시스템 호출을 할 때는 특별한 시스템 호출 기계어 명령어를 실행한다.
INIT , SYSCALL, TRAP 등이 있다. 

이와 같이 모드 레지스터 값이 1로 바뀌고 시스템 호출시 준비된 
커널 명령어로 커널 이 실행이된다.  


SS 커널 모드가 사용자 공간 뿐만 아니라 커널 공간까지도 사용할 수 있다.
가상 주소 공간과 물리 주소 공간의 차이 때문에 다르게 느껴지지만 가능합니다. 커널 모드에서는 모든 메모리 공간 엑세스 가능합니다.

SS 특권 명령이란 ?

커널 모드에서 실행할 특별한 목적으로 설계된 CPU명령이다. 
커널 코드 속에서 실행한다는 것이다.
종류로는 I/O 명령 으로 하드웨어 제어 및 장치로부터의 입출력이있다.

SS I.O 포트란 무엇인가 ? 

메모리는 0 번지 부터 저장이 된다
저장 공간이 메모리에만 있는것은 아니다.
그래픽 카드 안에도 레지스터 공간들이 있다. 
또 디스크 장치 안 DISK CONTROLLER BLOCK에도 레지스터가 있다
메모리의 번지와 레지스터 메모리 공간을 분리시킨다
IO 장치에 들어있는 저장공간을 IO 포트라고 한다. 

mov eax [0]
메모리 0번지에서 읽어서 eax레지스터로 가져온다

in eax 0 
i/o 포트 0번지에서 데이터를 읽어와라

out 1 eax 
1번지에 eax 값을 써라 

이와 같이 in , out 과 같은 것을 ,io 명령이라고 한다. 이는 커널만 접근할 수 있는 특권명령이다. io 포트에 서 읽고 쓰는것 , io 장치에서 읽고 쓰는것을 말한다. 


SS HALT 명령어란 무엇인가 ? 
CPU의 작동을 중지시키는것이다.
예를 들어 ,IO 를 관리하고 있다가 쉬고 있는경우에  커널이 CPU에게 HALT라는 명령어를 준다.
hlt 라는 기계 명령어를 사용하면 저전력 상태로 바뀐다. 
커널이 스케쥴링하다가 할게 없으면 hlt 라는 halt 명령어를 사용해 전력을 줄인다.

SS shut down 과 halt 차이 ?
운영체제는 shut down , 운영체제가 스케줄링을 하다가 wait 상태가 된다.
cpu를 중단시키기 위해서 halt 를 실행.
춤 잠깐 멈추고 힘을 뺀다. 일꾼들한테 잠깐 멈춰라. halt 할일 없으면 잠시 쉬어라. cycle를 계속 돌지않는다.
shut down은 컴퓨터를 끄는 동작 , 프로세스 메모리 해제 파일 닫기 등으로 컴퓨터를 파일 다운.



SS 인터럽트 플래그 켜고 끄는것은 ? 

CPU안에는 플래그 레지스터가 있다. 그 플래그 레지스터에 영어로 
인터럽트를 받지 말아라 라는 것을 명령한다.
cli clear interrrup flag, sti 등의 명령어로 sti 를 하면 다시 인터럽트를 받는다.
지금 바쁘니 이 일을 먼저 하라고 한다. 굉장히 중요한일을 처리할 때 기계어 프로그램을 짠다.응용 프로그램을 cli 할 때 잠깐 컨택스트 스위칭을 하면 
그때 인터럽트가 전혀 오지 않는다. 따라서 응용 프로그램이 직접 관리 못하게 한다.

SS 메모리 지우기, 장치 상태 테이블 수정, 컨택스트 스위칭, 타이머 설정 등 


SS 특권명령어 에 대한 문제이다.
SS사용자 모드에서 커널 모드로 변경시키는 명령어는 특권명령인가 ? 

특권 명령어가 아니다. 왜냐하면 시스템 호출을 위해 모든 응용 프로그램에게 허용되어야하는 명령이기 때문이다.  커널 만 해야하는일이 아니기때문이다. 
사용자 모드에서 사용해야하는 명령이기 때문에

SS 시계읽기
누구나 읽어야한다 

SS 가상 메모리에서 메모리 지우기 
특권 명령이 아니다
가상 메모리에서 이루어지는 부분이다. 

SS 인터럽트 끄기 


SS 실행 모드와 관련된 다양한 이슈 중 사용자 모드와 커널 모드는 CPU에서 구현되는기능인가 ? 아니면 운영체제에서 구현되는기능인가 ? 

CPU의 기능이다. CPU 내부에 모드를 나타내는 레지스터가 존재 
CPU가 지원하는 기능이다. 운영체제는 이런 CPU의 특징을 이용해서 두 모드를 활용하는 것이다 .

SS 운영체제가 모드를 나누어 작동시키는 이유?

보안과 보호 

SS 사용자 응용프로그램이 커널 코드를 호출할 수 있는가 ?

없다 

SS CPU가 평균적으로 커널 모드에서 많이 실행될까 ?

그렇다 


SS 커널이란 ? 

함수들의 집합 이다. 

OBJ 형태는 이진수 바이너리 형태로 하드디스크 영역에 저장이 되어잇는것이다. 부팅이 되면 부트블록이 저장되어있는 것 바이너리 코드를 읽어다가 
메모리에 그대로 올리는것이다. 
함수들의 집합이 OBJ에 있다가 올라오는 것이다. 
메모리 공간에는 함수들이 존재한다.  커널 코드는 함수들의 집합이다.
따라서 커널은 스스로 도는것이라고 볼 수 없다. 
커널은 실행 중인 프로세스가 아니다. 실행 중인 것이 아니라 함수를 호출하는 것일 뿐이다. 사용자 공간에서 파일을 읽어서 시스템호출을 하고 
커널 모드로 바뀌어서 시스템 호출 핸들러가 처리가 되어서 이 핸들러가
커널 함수를 호출한다. 그리고 디바이스 드라이버 코드를 부른다. IO 명령들을 써서 디스크를 가동시키는 과정을 사용해서 말이다. 
"애플리케이션이 커널 모드에서 실행중이다",
"프로세스나 스레드가 시스템 호출을 통해 커널 코드를 실행하고 있다" 라고 해야한다. 실행의 주체는 프로세스나 스레드 의 단위로 된다.
실행의 단위만이 실행을 하는 것이지 커널이라는 실행의 주체 ,단위는 없다. 
 

SS 커널은 스스로 실행되는 프로세스인가 ?

커널에 있는 스케쥴러가 프로세스인가요 ? 아니요 
스케쥴링만 할 뿐 스스로 실행되는 프로세스는 아니다. 스케쥴링도 코드이다.

SS 커널은 스택이나 힙을 가지는가 ?

응용프로그램이 실행될 때마다 스택이 호출된다 
그런데 커널 모드로 진입하게 되면  스케쥴러가 상황에 맞는 함수를 호출시킨다. 스케줄러를 위해서 스택을 하나 할당해준다. 
따라서 커널 모드로 들어와서 커널 공간을 실행하면서 함수가 호출되거나 임의로 스택에 저장하는 그 무언가를 위해서 커널 내 스택을 만들어준다. 
커널 스택이 있고 , 커널이 스택을 소유한다는것은 있을 수 없는 말이다. 
프로세스나 스레드가 스택을 소유하는것이다. 실행 단위만이 스택을 소유할 수 있는것이고 , 함수 및 코드의 집합은 스택을 소유할 수 없다 .


SS 응용 프로그램이 어떻게 생겼고, 운영체제와의 관계는 어떠한가 ?

응용 프로그램이 활용하는 라이브러리는 2가지 유형이 있다. 
표준 라이브러리와 시스템호출 라이브러리가 있다. 
예를 들어 PRINTF는 표준 라이브러리 WRITE는 시스템호출 라이브러리이다.
표준 라이브러리의 목적은 운영체제나 하드웨어에 상관없이 이름과 사용법이 동일하다. 의미가 동일하고 잘 컴파일이 된다. 이와 같은 표준 라이브러리를 제공하는 이유는 사용자가 작성하기 힘든 함수를 제공하기 때문이다. 편리성을 위해서이다. 반면 시스템 호출 라이브러리는 시스템 호출을 진행하기 위한 라이브러리이다. 목적이 다르다 . WRITE를 쓰면 시스템호출이 진행되는것이다. 운영체제가 가지고 잇는 기능을 반드시 써야할 때, 시스템 호출 라이브러리를 사용하는것이다. 운영체제마다 함수의 이름이 서로 다르다. 
LINUX에서 FORK() 가 WINDOW 에서는 CREATEPROCESS()가 된다. 
따라서 운영체제마다 환경이 다르고 언어가 다르다는것을 확인할 수 있다. 
운영체제마다 독특한 기능을 가지고 있기 때문에 함수이름이 다른것이다. 

SS 프로그램 과정 설명하라 

1. MAIN() 
->2. F()
->3. G()
->4. U()

PRINTF 
STRCPY
ABS 

를 사용하면 CLASS가 OBJ 파일로 변환이 된다. 
이와같은 함수를 불러썼는데, C라이브러리 라고 컴파일 된 함수들의 집합에서 링크를 한다. 링커가  보니까 PRINTF(), STRCPY() ,WRITE() , OPEN() 등을 모두 합친다. 그리고 주소를 넣어서 EXE 파일을 만든다
즉 EXE 안에는 내가 짠 프로그램과 라이브러리가 모두 결합되어잇는 상태 이다. 하드디스크에 있다가 사용자의 메모리 공간으로 올라온것이다. 그리고 메인 부터 실행을 시작하는 것이다. 

MAIN에서 함수 호출을 한다. 이와 같은 호출을 반복하다가 
어떤 경우에는 화면에 출력하기 위해 내부적으로 WRITE를 불러
스크린 장치에 접근하려고 한다. 그 때 시스템 호출을 하게 되는것이다. 
WRITE 에는 시스템 호출하는 기계어가 있다. 시스템 호출 기계어를읽어서
시스템 호출 핸들러가 처리를 하고 실행을 하게 된다. 
시스템 커널 안에 만들어 놓은 화면을 출력하는 기능의 함수를 WRITE가 
부르는 것

SS 라이브러리는 사용자 영역에 존재하는가 ?

EXE 상태로 사용자영역에 로딩된다. 사용자 영역에 존재한다.

SS 함수 호출과 시스템 콜을 차이를 말하라 

함수 호출은 유저의 응용 프로그램 내에서 함수를 호출하는것 
시스템콜은 사용자영역에서 커널영역에 있는 함수를 호출하는것


SS 커널 함수들은 어떻게 구분되는가 ?
ID 번호로 구분이된다. 시스템 콜할 때 번호를 넘겨주면 
몇번 함수를 호출하는것인지 알게된다. 


SS 시스템 호출의 다른 이름은 ?
TRAP 
시스템 호출 라이브러리를 이용해서 시스템호출을 하면 된다 

SS 프로세스가 커널 모드가 된다. 
CPU는 일을 하는 수동적인 아이이고, 
실질적으로 일을 수행하는 것은 프로세스입니다. 
모드를 조절하는 것은 프로세스라고 이해를 하면 된다

SS 시스템 호출 과정을 그려라

read(rd,buffer,mBytes) 라는 시스템 호출 라이브러리를 사용해서
cpu의 특정 레지스터들에 파일 읽기 서비스를 요청하는 시스템 호출번호와
매개변수를 저장한다. 
그리고 커널 코드로 진입시키는 CPU명령 SYSCALL를 실행한다 
CPU는 커널 모드로 변경한다. 
시스템 호출 핸들러 가실행이된다. 핸들러가 커널 스택을 마련하고
CPU레지스터를 읽어 시스템 호출 번호를 알아낸다. 
그리고 시스템 호출 표로 부터 커널함수의 주소를 알아낸다.

그리고 커널 함수를 호출한다. SYS_READ() 라는 함수를 호출하여 디스크 장치를 제어하여 파일을 읽고 커널 스택으로 CPU레지스터를 복귀하고 
SYS RETURN명령어를 실행하여 커널 함수를 종료하고 다시 시스템 호출 함수를 종료하고 호출한 곳으로 리턴한다. 

SS WRITE() 함수는 어떻게 만들어졌는가 ? 

과제 

SS FREAD()와 READ()의 차이점을 설명하라 

FREAD를 읽을 경우에는 표준 라이브러리에는 버퍼가 있다. 따라서 
디스크에서 읽어오는 것은 READ()를 함수 호출한다. READ()는 시스템 콜을 한다. 그리고 FREAD()는 READ()에게 한 블록을 읽어줘 라고 얘기를한다. 
그리고 READ는 시스템 콜 과정을 통해서 디스크에서 파일을 읽어서 4KB를 읽는다 그리고 100BYTE를 전달한다. 그리고 그다음 100 바이트를 준다. 계속해서 100바이트를 준다. 그런데 만약 READ라고 하면 표준 라이브러리를 거치지않고 바로 시스템 호출 라이브러리를 호출하해서 100 바이트를 읽을 것을 요청한다. 그렇게 해서 100바이트를 계쏙 요청하면 

SS 시스템호출은 좋은것인가 ? 
시스템 호출은 필연적이다.
시스템 호출을 많이 할 수록 비효율적이다. 
따라서 호출 회수를 줄여야한다 

시스템 호출 내에서 컨택스트 스위칭이 이루진다.











































































 





































































 



























































